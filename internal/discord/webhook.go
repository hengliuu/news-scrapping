package discord

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/hengky/news-scrapping/pkg/models"
)

// WebhookClient handles Discord webhook operations
type WebhookClient struct {
	webhookURL string
	httpClient *http.Client
}

// New creates a new Discord webhook client
func New(webhookURL string) *WebhookClient {
	return &WebhookClient{
		webhookURL: webhookURL,
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

// DiscordEmbed represents a Discord embed structure
type DiscordEmbed struct {
	Title       string       `json:"title"`
	Description string       `json:"description"`
	URL         string       `json:"url"`
	Color       int          `json:"color"`
	Footer      *EmbedFooter `json:"footer,omitempty"`
	Timestamp   string       `json:"timestamp,omitempty"`
}

// EmbedFooter represents Discord embed footer
type EmbedFooter struct {
	Text string `json:"text"`
}

// DiscordMessage represents a Discord webhook message
type DiscordMessage struct {
	Content string         `json:"content,omitempty"`
	Embeds  []DiscordEmbed `json:"embeds,omitempty"`
}

// SendNews sends curated AI news to Discord (backward compatibility)
func (c *WebhookClient) SendNews(newsResponse *models.NewsResponse) error {
	return c.SendNewsByType(newsResponse, "ai")
}

// SendNewsByType sends curated news to Discord with type-specific formatting
func (c *WebhookClient) SendNewsByType(newsResponse *models.NewsResponse, newsType string) error {
	return c.SendNewsByTypeToWebhook(newsResponse, newsType, c.webhookURL)
}

// SendNewsByTypeToWebhook sends news to a specific webhook URL
func (c *WebhookClient) SendNewsByTypeToWebhook(newsResponse *models.NewsResponse, newsType string, webhookURL string) error {
	if len(newsResponse.News) == 0 {
		return fmt.Errorf("no news items to send")
	}

	log.Printf("Sending %d %s news items to Discord webhook %s", len(newsResponse.News), newsType, webhookURL)

	// Create type-specific header and emoji
	var header string
	var embedColor int
	if newsType == "global" {
		header = fmt.Sprintf("üåç **Daily Global Tech News** - %s", time.Now().Format("January 2, 2006"))
		embedColor = 0x1E88E5 // Blue color for global news
	} else {
		header = fmt.Sprintf("ü§ñ **Daily AI Tech News** - %s", time.Now().Format("January 2, 2006"))
		embedColor = 0x00D4AA // Green color for AI news
	}

	// Create Discord message with embeds
	message := DiscordMessage{
		Content: header,
		Embeds:  make([]DiscordEmbed, 0, len(newsResponse.News)),
	}

	// Convert each news item to Discord embed
	for i, item := range newsResponse.News {
		embed := DiscordEmbed{
			Title:       fmt.Sprintf("%d. %s", i+1, item.Title),
			Description: formatDescription(item),
			URL:         item.URL,
			Color:       embedColor,
			Footer: &EmbedFooter{
				Text: fmt.Sprintf("Source: %s", item.Source),
			},
			Timestamp: time.Now().Format(time.RFC3339),
		}

		message.Embeds = append(message.Embeds, embed)
	}

	// Add footer embed with bot info and token usage
	footerText := "_Generated by AI News Bot powered by Gemini 2.5 Flash_"
	if newsResponse.TokenUsage != nil {
		footerText += fmt.Sprintf("\nüìä **Token Usage**: Input: %d | Output: %d | Total: %d",
			newsResponse.TokenUsage.InputTokens,
			newsResponse.TokenUsage.OutputTokens,
			newsResponse.TokenUsage.TotalTokens)
	}

	footerEmbed := DiscordEmbed{
		Description: footerText,
		Color:       0x7289DA, // Discord blue color
	}
	message.Embeds = append(message.Embeds, footerEmbed)

	// Send to Discord using the specific webhook
	return c.sendMessageToWebhook(message, webhookURL)
}

// SendSimpleMessage sends a simple text message to Discord
func (c *WebhookClient) SendSimpleMessage(content string) error {
	message := DiscordMessage{
		Content: content,
	}
	return c.sendMessage(message)
}

// sendMessage sends a message to Discord webhook
func (c *WebhookClient) sendMessage(message DiscordMessage) error {
	return c.sendMessageToWebhook(message, c.webhookURL)
}

// sendMessageToWebhook sends a message to a specific webhook URL
func (c *WebhookClient) sendMessageToWebhook(message DiscordMessage, webhookURL string) error {
	// Convert to JSON
	jsonData, err := json.Marshal(message)
	if err != nil {
		log.Printf("Failed to marshal Discord message: %v", err)
		return fmt.Errorf("failed to marshal Discord message: %w", err)
	}

	// Create HTTP request
	req, err := http.NewRequest("POST", webhookURL, bytes.NewBuffer(jsonData))
	if err != nil {
		log.Printf("Failed to create HTTP request for Discord webhook: %v", err)
		return fmt.Errorf("failed to create HTTP request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")

	// Send request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		log.Printf("Failed to send Discord webhook: %v", err)
		return fmt.Errorf("failed to send Discord webhook: %w", err)
	}
	defer resp.Body.Close()

	// Check response status
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNoContent {
		return fmt.Errorf("Discord webhook returned status %d", resp.StatusCode)
	}

	return nil
}

// formatDescription formats the news item description for Discord
func formatDescription(item models.NewsItem) string {
	description := item.Summary

	// Add relevance if available
	if item.Relevance != "" {
		description += "\n\n**Why it matters:** " + item.Relevance
	}

	// Add link
	description += fmt.Sprintf("\n\nüîó [Read more](%s)", item.URL)

	return description
}

// TestWebhook tests the Discord webhook connection
func (c *WebhookClient) TestWebhook() error {
	testMessage := DiscordMessage{
		Content: "üîß News Bot Test - Webhook connection successful!",
		Embeds: []DiscordEmbed{
			{
				Title:       "Connection Test",
				Description: "This is a test message to verify the Discord webhook is working correctly.",
				Color:       0x00FF00, // Green color
				Footer: &EmbedFooter{
					Text: "Test completed",
				},
				Timestamp: time.Now().Format(time.RFC3339),
			},
		},
	}

	return c.sendMessage(testMessage)
}
